<H2> GIT </H2>
<P ALIGN="CENTER">
    SOFTWARE SUGERIDO: 
    <A HREF="HTTPS://GIT-SCM.COM/DOWNLOADS" TARGET="_BLANK">GITBASH</A>
</P>
<H3>CONFIGURAÇÃO</H3>
<P ALIGN="JUSTIFY">AS CONFIGURAÇÕES DO GIT SÃO ARMAZENADAS NO ARQUIVO (.GITCONFIG) LOCALIZADO NO DIRETÓRIO DO USUÁRIO E AS CONFIGURAÇÕES REALIZADAS ATRAVÉS DOS COMANDOS ABAIXO SERÃO INCLUÍDAS NESTE MESMO ARQUIVO.
</P>

##### SETAR USUÁRIO
	GIT CONFIG --GLOBAL USER.NAME "LEON4RDOALVES"
##### SETAR EMAIL
	GIT CONFIG --GLOBAL USER.EMAIL LEONARDO@EBONYSYS.OR
##### SETAR EDITOR
	GIT CONFIG --GLOBAL CORE.EDITOR VIM
##### SETAR FERRAMENTA DE MERGE
	GIT CONFIG --GLOBAL MERGE.TOOL VIMDIFF
##### SETAR ARQUIVOS A SEREM IGNORADOS
	GIT CONFIG --GLOBAL CORE.EXCLUDESFILE ~/.GITIGNORE
##### LISTAR CONFIGURAÇÕES
	GIT CONFIG --LIST

<P ALIGN="JUSTIFY">
    IMPORTANTE LEMBRAR QUE VOCÊ PODE OPTAR POR CONFIGURAR APENAS O <STRONG>NOME DE USUÁRIO</STRONG> E <STRONG>EMAIL</STRONG>, AS DEMAIS CONFIGURAÇÕES PODEM SEGUIR COMO POR PADRÃO. 
</P>
<H3>AJUDA</H3>

	GIT HELP
	GIT HELP ADD
	GIT HELP COMMIT
    GIT HELP PUSH	
    GIT HELP <QUALQUER_COMANDO_GIT>

<H3>ESTADOS</H3>
♦ MODIFICADO (MODIFIED) <BR>
♦ PREPARADO (STAGED/INDEX) <BR>
♦ CONSOLIDADO (COMITTED)

<H3>IGNORAR ARQUIVOS</H3>
<P ALIGN="JUSTIFY">
NO ARQUIVO (.GITIGNORE) VOCÊ PODE LISTAR ARQUIVOS, DIRETÓRIOS E/OU
EXTENSÕES QUE NÃO DEVEM SER ENVIADOS AO SEU REPOSITÓRIO NO GITHUB.
TEMOS DUAS POSSIBILIDADES DE USABILIDADE QUANTO AO ARQUIVO .GITIGNORE.

♦ **GERAL**: NORMALMENTE ARMAZENADO NO DIRETÓRIO DO USUÁRIO. O ARQUIVO QUE
POSSUI A LISTA DOS ARQUIVOS/DIRETÓRIOS A SEREM IGNORADOS POR <STRONG>
TODOS OS REPOSITÓRIOS</STRONG> DEVERÁ SER DECLARADO CONFORME CITADO 
ACIMA. <BR>

♦ **POR REPOSITÓRIO**: DEVE SER ARMAZENADO NO DIRETÓRIO DO REPOSITÓRIO
E DEVE CONTER A LISTA DOS ARQUIVOS/DIRETÓRIOS QUE DEVEM SER IGNORADOS 
APENAS PARA O REPOSITÓRIO ESPECÍFICO.
</P>
<H3>REPOSITÓRIO LOCAL</H3>
<H4 ALIGN="CENTER">CRIANDO UM REPOSITÓRIO...</H4>

	GIT INIT NOME
<H4 ALIGN="CENTER">VERIFICANDO STATUS...</H4>

	GIT STATUS
<H4 ALIGN="CENTER">ADIDIONANDO...</H4>

##### ADICIONAR UM ARQUIVO EM ESPECÍFICO
	GIT ADD ARQUIVO.EXTENSÃO
##### ADICIONAR UM DIRETÓRIO EM ESPECÍFICO
	GIT ADD DIRETORIO
##### ADICIONAR TODOS OS ARQUIVOS/DIRETÓRIOS
	GIT ADD .
##### ADICIONAR UM ARQUIVO QUE ESTÁ LISTADO NO .GITIGNORE
	GIT ADD -F ARQUIVO_NO_GITIGNORE.EXTENSÃO

<H4 ALIGN="CENTER">COMMITANDO ARQUIVOS...</H4>

##### COMITAR UM ARQUIVO	
	GIT COMMIT ARQUIVO.EXTENSÃO
##### COMITAR VÁRIOS ARQUIVOS
	GIT COMMIT ARQUIVO.EXTENSÃO OUTRO_ARQUIVO.EXTENSÃO
##### COMITAR INFORMANDO MENSAGEM (MAIS USUAL)
	GIT COMMIT ARQUIVO.EXTENSAO -M "MENSAGEM DE COMMIT"

<H4 ALIGN="CENTER">REMOVENDO...</H4>

##### REMOVER ARQUIVO
	GIT RM ARQUIVO.EXTENSÃO
##### REMOVER DIRETÓRIO
	GIT RM -R DIRETORIO

<H4 ALIGN="CENTER">VISUALIZANDO HISTÓRICO...</H4>

##### EXIBIR HISTÓRICO	
	GIT LOG	
##### EXIBIR HISTÓRICO COM DIFF DAS DUAS ÚLTIMAS ALTERAÇÕES
	GIT LOG -P -2	
##### EXIBIR RESUMO DO HISTÓRICO 
	GIT LOG --STAT
##### EXIBIR INFORMAÇÕES RESUMIDAS EM UMA LINHA
	GIT LOG --PRETTY=ONELINE	
##### EXIBIR HISTÓRICO COM FORMATAÇÃO ESPECÍFICA
	GIT LOG --PRETTY=FORMAT:"%H - %AN, %AR : %S"
	
♦ %H: ABREVIAÇÃO DO HASH;<BR>
♦ %AN: NOME DO AUTOR;<BR>
♦ %AR: DATA;<BR>
♦ %S: COMENTÁRIO.<BR>

<P ALIGN="CENTER">
    ...MAIS OPÇÕES DE FORMATAÇÃO:  
    <A HREF="HTTP://GIT-SCM.COM/BOOK/EN/GIT-BASICS-VIEWING-THE-COMMIT-HISTORY" TARGET="_BLANK">GIT BOOK</A>
</P>

##### EXIBIR HISTÓRIO DE UM ARQUIVO ESPECÍFICO
	GIT LOG -- <CAMINHO_DO_ARQUIVO>
##### EXIBIR HISTÓRICO DE UM ARQUIVO ESPECÍFICO QUE CONTÊM UMA DETERMINADA PALAVRA
	GIT LOG --SUMMARY -S<PALAVRA> [<CAMINHO_DO_ARQUIVO>]
##### EXIBIR HISTÓRICO MODIFICAÇÃO DE UM ARQUIVO
	GIT LOG --DIFF-FILTER=M -- <CAMINHO_DO_ARQUIVO>

♦ O **M** PODE SER SUBSTITUIDO POR: 
+ **A** ADICIONADO
+ **C** COPIADO 
+ **D** APAGADO 
+ **M** MODIFICADO 
+ **R** RENOMEADO<BR> 
...ENTRE OUTROS.

##### EXIBIR HISTÓRIO DE UM DETERMINADO AUTOR
	GIT LOG --AUTHOR=USUARIO
##### EXIBIR REVISÃO E AUTOR DA ÚLTIMA MODIFICAÇÃO DE UMA BLOCO DE LINHAS
	GIT BLAME -L 12,22 ARQUIVO.EXTENSÃO 

<H4 ALIGN="CENTER">DESFAZENDO ALTERAÇÕES...</H4>

##### DESFAZENDO ALTERAÇÃO LOCAL (WORKING DIRECTORY) → *ANTES DA STAGED AREA*  
	GIT CHECKOUT -- ARQUIVO.EXTENSÃO
##### DESFAZENDO ALTERAÇÃO LOCAL (STAGING AREA) → *DEPOIS DE ADC NA STAGED AREA*
	GIT RESET HEAD ARQUIVO.EXTENSÃO

PÓS UTILIZAR ESTE COMANDO... CASO SEJA EXIBIDA ESTA SAÍDA:

	UNSTAGED CHANGES AFTER RESET:
	M	ARQUIVO.EXTESNSÃO

SIGNIFICA QUE O COMANDO RESET **NÃO** ALTEROU O DIRETÓRIO DE TRABALHO. 
O QUE PODE SER FEITO ATRAVÉS DO COMANDO:

	GIT CHECKOUT ARQUIVO.EXTENSÃO

<H3>REPOSITÓRIO REMOTO</H3>
<H4 ALIGN="CENTER">VINCULANDO...</H4>

##### VINCULAR REPOSITÓRIO LOCAL COM UM REPOSITÓRIO REMOTO
	GIT REMOTE ADD ORIGIN GIT@GITHUB.COM:NOMEDEUSUARIO/NOMEDOREPOSITÓRIO.GIT
##### DESVINCULAR UM REPOSITÓRIO REMOTO
	GIT REMOTE RM CURSO-GIT

<H4 ALIGN="CENTER">VISUALIZANDO...</H4>

##### REPOSITÓRIOS
	GIT REMOTE
	GIT REMOTE -V
##### EXIBIR INFORMAÇÕES DOS REPOSITÓRIOS REMOTOS
	GIT REMOTE SHOW ORIGIN

<H4 ALIGN="CENTER">RENOMEANDO UM REPOSITÓRIO...</H4>

	GIT REMOTE RENAME ORIGIN CURSO-GIT

<H4 ALIGN="CENTER">CLONANDO...</H4>

##### CLONAR UM REPOSITÓRIO REMOTO JÁ EXISTENTE NO SEU PC
	GIT CLONE GIT@GITHUB.COM:NOMEDEUSUARIO/NOMEDOREPOSITORIO.GIT

<H4 ALIGN="CENTER">ATUALIZANDO...</H4>

##### ENVIAR ARQUIVOS/DIRETÓRIOS PARA O REPOSITÓRIO REMOTO

O PRIMEIRO **PUSH** DE UM REPOSITÓRIO DEVE CONTER O NOME DO 
REPOSITÓRIO REMOTO E O BRANCH.

	GIT PUSH -U ORIGIN MASTER
	
AINDA QUE UMA BOA PRATICA MANTER, OS DEMAIS **PUSHES** NÃO 
PRECISAM DESSA INFORMAÇÃO.

	GIT PUSH
	
##### BUSCAR AS ALTERAÇÕES, MAS NÃO APLICA-LAS NO BRANCH ATUAL
	GIT FETCH
##### ATUALIZAR OS ARQUIVOS NO BRANCH ATUAL
	GIT PULL

<H4 ALIGN="CENTER">TAGS...</H4>

##### CRIANDO UMA TAG LEVE
	GIT TAG VS-1.1
##### CRIANDO UMA TAG ANOTADA
	GIT TAG -A VS-1.1 -M "MINHA VERSÃO 1.1"
##### CRIANDO UMA TAG ASSINADA
PARA CRIAR UMA TAG ASSINADA É NECESSÁRIO UMA CHAVE PRIVADA 
(GNU PRIVACY GUARD - GPG).
    
    GIT TAG -S VS-1.1 -M "MINHA TAG ASSINADA 1.1"
    
##### CRIANDO TAG A PARTIR DE UM COMMIT (HASH)
	GIT TAG -A VS-1.2 9FCEB02
##### CRIANDO TAGS NO REPOSITÓRIO REMOTO
	GIT PUSH ORIGIN VS-1.2
##### CRIANDO TODAS AS TAGS LOCAIS NO REPOSITÓRIO REMOTO
	GIT PUSH ORIGIN --TAGS
	
<H4 ALIGN="CENTER">BRANCH...</H4>
A **MAIN** É A BRANCH PRINCIPAL DO GIT. VOCÊ PODE ENCONTRAR TAMBÉM PELO
NOME DE **MASTER**, PORÉM, ESTE TERMO DE CUNHO RACISTA FOI ELIMINADO,
MAS AINDA É ECONTRADO EM SOFTWARES DESATUALIZADOS.

O **HEAD** É UM PONTEIRO *ESPECIAL* QUE INDICA QUAL É A BRANCH ATUAL. 
POR PADRÃO, O **HEAD** APONTA PARA A BRANCH PRINCIPAL, **MAIN**.

##### CRIANDO UMA NOVA BRANCH
	GIT BRANCH NOMENOVABRANCH
##### TROCANDO PARA UM BRANCH (EXISTENTE)
	GIT CHECKOUT NOMEBRANCHEXISTENTE
	
...DESTE MOMENTO PRA FRENTE, O PONTEIRO PRINCIPAL **HEAD** ESTARÁ 
APONTANDO PARA O BRANCH NOMEBRANCHEXISTENTE.

##### CRIAR UMA NOVA BRANCH E TROCAR AUTOMATICAMENTE
	GIT CHECKOUT -B NOVABRANCH
##### VOLTAR PARA O BRANCH PRINCIPAL (MAIN)
	GIT CHECKOUT MAIN

<H4 ALIGN="CENTER">MERGING...</H4>
VALE RESSALTAR QUE, PARA FAZER O **MERGE**, É NECESSÁRIO ESTAR NA 
BRANCH QUE DEVERÁ RECEBER AS ALTERAÇÕES. OU SEJA, SE EU QUERO QUE 
A BRANCH **MAIN** RECEBA AS ATUALIZAÇÕES QUE FORAM FEITAS NA BRANCH
**UPSTREAM**, EU PRECISO QUE O **HEAD** ESTEJA APONTANDO PARA A MAIN
NO MOMENTO QUE FIZER O MERGING. <BR>

O MERGE AUTOMÁTICO SERÁ FEITO EM ARQUIVOS 
TEXTOS QUE NÃO SOFRERAM ALTERAÇÕES NAS MESMAS LINHAS, JÁ O MERGE 
MANUAL SERÁ FEITO EM ARQUIVOS TEXTOS QUE SOFRERAM ALTERAÇÕES NAS 
MESMAS LINHAS.

##### MERGE ENTRE OS BRANCHES → ESTANDO NA BRANCH MAIN
	GIT MERGE UPSTREAM

A MENSAGEM INDICANDO UM *MERGE* MANUAL SERÁ:

	AUTOMERGING ARQUIVO.EXTENSÃO
	CONFLICT (CONTENT): MERGE CONFLICT IN ARQUIVO.EXTENSÃO
	AUTOMATIC MERGE FAILED; FIX CONFLICTS AND THEN COMMIT THE RESULT.

##### APAGANDO UMA BRANCH
	GIT BRANCH -D NOMEDABRANCH
##### LISTAR BRANCHES 
	GIT BRANCH
##### LISTAR BRANCHES COM INFORMAÇÕES DOS ÚLTIMOS COMMITS
	GIT BRANCH -V
##### LISTAR BRANCHES QUE JÁ FORAM FUNDIDAS (MERGED) COM O **MAIN**
	GIT BRANCH --MERGED
##### LISTAR BRANCHES QUE NÃO FORAM FUNDIDAS (MERGED) COM O **MAIN**
	GIT BRANCH --NO-MERGED

<H4 ALIGN="CENTER">BRANCH REPOSITÓRIO REMOTO...</H4>

##### CRIANDO COM O MESMO NOME
	GIT PUSH ORIGIN NOMEDABRANCH
##### CRIANDO COM NOME DIFERENTE
	GIT PUSH ORIGIN NOMEDABRANCH:NOVABRANCH
##### BAIXAR UMA BRANCH REMOTO PARA EDIÇÃO
	GIT CHECKOUT -B NOMEDABRANCH ORIGIN/NOMEDABRANCH
##### APAGAR BRANCH REMOTO
	GIT PUSH ORIGIN:NOMEDABRANCH

<H4 ALIGN="CENTER">REBASING...</H4>

##### FAZENDO O **REBASE** ENTRE UMA BRANCH UPSTREAM E A MAIN.

	GIT CHECKOUT EXPERIMENT
	GIT REBASE MAIN

<P ALIGN="CENTER">
    ...MAIS INFORMAÇÕES SOBRE REBASE:  
    <A HREF="HTTP://GIT-SCM.COM/BOOK/EN/GIT-BRANCHING-REBASING" TARGET="_BLANK">GIT REBASING</A>
</P>

<H4 ALIGN="CENTER">STASHING...</H4>
PARA ALTERNAR ENTRE UMA BRANCH E OUTRA É NECESSÁRIO FAZER O COMMIT 
DAS ALTERAÇÕES ATUAIS PARA DEPOIS TROCAR DE BRANCH. SE EXISTIR A 
NECESSIDADE DE REALIZAR A TROCA SEM FAZER O COMMIT É POSSÍVEL CRIAR 
UM **STASH**. 

O STASH É COMO SE FOSSE UMA BRANCH TEMPORÁRIA QUE CONTEM APENAS AS 
ALTERAÇÕES AINDA NÃO COMMITADAS.

##### CRIAR UM STASH
	GIT STASH
##### LISTAR STASHES
	GIT STASH LIST
##### VOLTAR PARA O ÚLTIMO STASH
	GIT STASH APPLY
##### VOLTAR PARA UM STASH ESPECÍFICO
	GIT STASH APPLY STASH@{2}
ONDE **2** É O INDÍCE DO STASH DESEJADO.
##### CRIAR UMA BRANCH A PARTIR DE UM STASH
	GIT STASH BRANCH NOMEBRANCH

<H4 ALIGN="CENTER">REESCREVENDO HISTÓRICO...</H4>

##### ALTERANDO MENSAGENS DE COMMIT
	GIT COMMIT --AMEND -M "NOVA MENSAGEM"
##### ALTERAR 3 ÚLTIMOS COMMITS
	GIT REBASE -I HEAD~3

O EDITOR DE TEXTO SERÁ ABERTO COM AS LINHAS REPRESENTANDO OS 3 ÚLTIMOS COMMITS.

	PICK F7F3F6D CRIEI UMA BRANCH PARA O MENU
	PICK 310154E ATUALIZEI AS FONTES DO MENU
	PICK A5F4A0D FINALIZEI O MENU

ALTERE PARA EDIT OS COMMITS QUE DESEJA REALIZAR ALTERAÇÕES.

	EDIT F7F3F6D CRIEI UMA BRANCH PARA O MENU E RODAPÉ
	PICK 310154E ATUALIZEI AS FONTES DO MENU
	PICK A5F4A0D FINALIZEI O MENU

FECHE O EDITOR DE TEXTO.

AGORA, DIGITE ESTE COMANDO PARA ALTERAR A MENSAGEM DO COMMIT 
QUE FOI MARCADO COMO **EDIT**.

	GIT COMMIT –AMEND -M “NOVA MENSAGEM”

APLIQUE A ALTERAÇÃO

	GIT REBASE --CONTINUE

**ATENÇÃO:** É POSSÍVEL ALTERAR A ORDEM DOS COMMITS OU REMOVER 
UM COMMIT APENAS MUDANDO AS LINHAS OU REMOVENDO.

<H4 ALIGN="CENTER">SQUASHING...</H4>

##### JUNTANDO VÁRIOS COMMITS
SEGUIR OS MESMOS PASSOS ACIMA, PORÉM MARCAR OS COMMTIS QUE DEVEM 
SER JUNTADOS COM **SQUASH**

<H4 ALIGN="CENTER">REMOVENDO HISTÓRICO...</H4>	

##### REMOVER TODO HISTÓRICO DE UM ARQUIVO
	GIT FILTER-BRANCH --TREE-FILTER 'RM -F PASSWORDS.TXT' HEAD

<H4 ALIGN="CENTER">BISECT...</H4>
O BISECT (PESQUISA BINÁRIA) É ÚTIL PARA ENCONTRAR UM COMMIT QUE 
ESTÁ GERANDO UM BUG OU UMA INCONSISTÊNCIA ENTRE UMA SEQUÊNCIA 
DE COMMITS.

##### INICIAR PESQUISA BINÁRIA
	GIT BISECT START
##### MARCAR O COMMIT ATUAL COMO RUIM
	GIT BISECT BAD
##### MARCAR O COMMIT DE UMA TAG QUE ESTA SEM O BUG/INCONSISTÊNCIA
	GIT BISECT GOOD VS-1.1
##### MARCAR O COMMIT COMO GOOD (BOM)

O GIT IRÁ NAVEGAR ENTRE OS COMMITS PARA AJUDAR A INDENTIFICAR O 
COMMIT QUE ESTÁ COM O PROBLEMA. SE O COMMIT ATUAL NÃO ESTIVER 
QUEBRADO, ENTÃO É NECESSÁRIO MARCA-LO COMO **BOM**.

	GIT BISECT GOOD

##### MARCAR O COMMIT COMO BAD (RUIM)
SE O COMMIT ESTIVER COM O PROBLEMA, ENTÃO ELE DEVERÁ SER MARCADO 
COMO **RUIM**.

 	GIT BISECT BAD
 
##### FINALIZAR A PESQUISA BINÁRIA
DEPOIS DE ENCONTRAR O COMMIT COM PROBLEMA, PARA RETORNAR PARA O 
*HEAD* UTILIZE:
	
	GIT BISECT RESET

<HR>
ESTE CONTEÚDO NÃO ESTÁ COMPLETO, CASO QUEIRA CONTRIBUIR, SERÁ MUITO BEM ACEITO!

VÍDEOS MOSTRANDO NA PRÁTICA → [CANAL CÓDIGOS SIMPLES](HTTPS://WWW.YOUTUBE.COM/CHANNEL/UC8FRZFYGD21_D8DWUECFUHW)
</BR>CURSOS | MAIS INFORMAÇÕES → <A HREF="HTTPS://API.WHATSAPP.COM/SEND?PHONE=5511979714423">WHATSAPP</A>
<H2> GIT </H2>
<P ALIGN="CENTER">
    SOFTWARE SUGERIDO: 
    <A HREF="HTTPS://GIT-SCM.COM/DOWNLOADS" TARGET="_BLANK">GITBASH</A>
</P>
<H3>CONFIGURAÇÃO</H3>
<P ALIGN="JUSTIFY">AS CONFIGURAÇÕES DO GIT SÃO ARMAZENADAS NO ARQUIVO (.GITCONFIG) LOCALIZADO NO DIRETÓRIO DO USUÁRIO E AS CONFIGURAÇÕES REALIZADAS ATRAVÉS DOS COMANDOS ABAIXO SERÃO INCLUÍDAS NESTE MESMO ARQUIVO.
</P>

##### SETAR USUÁRIO
	GIT CONFIG --GLOBAL USER.NAME "LEON4RDOALVES"
##### SETAR EMAIL
	GIT CONFIG --GLOBAL USER.EMAIL LEONARDO@EBONYSYS.OR
##### SETAR EDITOR
	GIT CONFIG --GLOBAL CORE.EDITOR VIM
##### SETAR FERRAMENTA DE MERGE
	GIT CONFIG --GLOBAL MERGE.TOOL VIMDIFF
##### SETAR ARQUIVOS A SEREM IGNORADOS
	GIT CONFIG --GLOBAL CORE.EXCLUDESFILE ~/.GITIGNORE
##### LISTAR CONFIGURAÇÕES
	GIT CONFIG --LIST

<P ALIGN="JUSTIFY">
    IMPORTANTE LEMBRAR QUE VOCÊ PODE OPTAR POR CONFIGURAR APENAS O <STRONG>NOME DE USUÁRIO</STRONG> E <STRONG>EMAIL</STRONG>, AS DEMAIS CONFIGURAÇÕES PODEM SEGUIR COMO POR PADRÃO. 
</P>
<H3>AJUDA</H3>

	GIT HELP
	GIT HELP ADD
	GIT HELP COMMIT
    GIT HELP PUSH	
    GIT HELP <QUALQUER_COMANDO_GIT>

<H3>ESTADOS</H3>
♦ MODIFICADO (MODIFIED) <BR>
♦ PREPARADO (STAGED/INDEX) <BR>
♦ CONSOLIDADO (COMITTED)

<H3>IGNORAR ARQUIVOS</H3>
<P ALIGN="JUSTIFY">
NO ARQUIVO (.GITIGNORE) VOCÊ PODE LISTAR ARQUIVOS, DIRETÓRIOS E/OU
EXTENSÕES QUE NÃO DEVEM SER ENVIADOS AO SEU REPOSITÓRIO NO GITHUB.
TEMOS DUAS POSSIBILIDADES DE USABILIDADE QUANTO AO ARQUIVO .GITIGNORE.

♦ **GERAL**: NORMALMENTE ARMAZENADO NO DIRETÓRIO DO USUÁRIO. O ARQUIVO QUE
POSSUI A LISTA DOS ARQUIVOS/DIRETÓRIOS A SEREM IGNORADOS POR <STRONG>
TODOS OS REPOSITÓRIOS</STRONG> DEVERÁ SER DECLARADO CONFORME CITADO 
ACIMA. <BR>

♦ **POR REPOSITÓRIO**: DEVE SER ARMAZENADO NO DIRETÓRIO DO REPOSITÓRIO
E DEVE CONTER A LISTA DOS ARQUIVOS/DIRETÓRIOS QUE DEVEM SER IGNORADOS 
APENAS PARA O REPOSITÓRIO ESPECÍFICO.
</P>
<H3>REPOSITÓRIO LOCAL</H3>
<H4 ALIGN="CENTER">CRIANDO UM REPOSITÓRIO...</H4>

	GIT INIT NOME
<H4 ALIGN="CENTER">VERIFICANDO STATUS...</H4>

	GIT STATUS
<H4 ALIGN="CENTER">ADIDIONANDO...</H4>

##### ADICIONAR UM ARQUIVO EM ESPECÍFICO
	GIT ADD ARQUIVO.EXTENSÃO
##### ADICIONAR UM DIRETÓRIO EM ESPECÍFICO
	GIT ADD DIRETORIO
##### ADICIONAR TODOS OS ARQUIVOS/DIRETÓRIOS
	GIT ADD .
##### ADICIONAR UM ARQUIVO QUE ESTÁ LISTADO NO .GITIGNORE
	GIT ADD -F ARQUIVO_NO_GITIGNORE.EXTENSÃO

<H4 ALIGN="CENTER">COMMITANDO ARQUIVOS...</H4>

##### COMITAR UM ARQUIVO	
	GIT COMMIT ARQUIVO.EXTENSÃO
##### COMITAR VÁRIOS ARQUIVOS
	GIT COMMIT ARQUIVO.EXTENSÃO OUTRO_ARQUIVO.EXTENSÃO
##### COMITAR INFORMANDO MENSAGEM (MAIS USUAL)
	GIT COMMIT ARQUIVO.EXTENSAO -M "MENSAGEM DE COMMIT"

<H4 ALIGN="CENTER">REMOVENDO...</H4>

##### REMOVER ARQUIVO
	GIT RM ARQUIVO.EXTENSÃO
##### REMOVER DIRETÓRIO
	GIT RM -R DIRETORIO

<H4 ALIGN="CENTER">VISUALIZANDO HISTÓRICO...</H4>

##### EXIBIR HISTÓRICO	
	GIT LOG	
##### EXIBIR HISTÓRICO COM DIFF DAS DUAS ÚLTIMAS ALTERAÇÕES
	GIT LOG -P -2	
##### EXIBIR RESUMO DO HISTÓRICO 
	GIT LOG --STAT
##### EXIBIR INFORMAÇÕES RESUMIDAS EM UMA LINHA
	GIT LOG --PRETTY=ONELINE	
##### EXIBIR HISTÓRICO COM FORMATAÇÃO ESPECÍFICA
	GIT LOG --PRETTY=FORMAT:"%H - %AN, %AR : %S"
	
♦ %H: ABREVIAÇÃO DO HASH;<BR>
♦ %AN: NOME DO AUTOR;<BR>
♦ %AR: DATA;<BR>
♦ %S: COMENTÁRIO.<BR>

<P ALIGN="CENTER">
    ...MAIS OPÇÕES DE FORMATAÇÃO:  
    <A HREF="HTTP://GIT-SCM.COM/BOOK/EN/GIT-BASICS-VIEWING-THE-COMMIT-HISTORY" TARGET="_BLANK">GIT BOOK</A>
</P>

##### EXIBIR HISTÓRIO DE UM ARQUIVO ESPECÍFICO
	GIT LOG -- <CAMINHO_DO_ARQUIVO>
##### EXIBIR HISTÓRICO DE UM ARQUIVO ESPECÍFICO QUE CONTÊM UMA DETERMINADA PALAVRA
	GIT LOG --SUMMARY -S<PALAVRA> [<CAMINHO_DO_ARQUIVO>]
##### EXIBIR HISTÓRICO MODIFICAÇÃO DE UM ARQUIVO
	GIT LOG --DIFF-FILTER=M -- <CAMINHO_DO_ARQUIVO>

♦ O **M** PODE SER SUBSTITUIDO POR: 
+ **A** ADICIONADO
+ **C** COPIADO 
+ **D** APAGADO 
+ **M** MODIFICADO 
+ **R** RENOMEADO<BR> 
...ENTRE OUTROS.

##### EXIBIR HISTÓRIO DE UM DETERMINADO AUTOR
	GIT LOG --AUTHOR=USUARIO
##### EXIBIR REVISÃO E AUTOR DA ÚLTIMA MODIFICAÇÃO DE UMA BLOCO DE LINHAS
	GIT BLAME -L 12,22 ARQUIVO.EXTENSÃO 

<H4 ALIGN="CENTER">DESFAZENDO ALTERAÇÕES...</H4>

##### DESFAZENDO ALTERAÇÃO LOCAL (WORKING DIRECTORY) → *ANTES DA STAGED AREA*  
	GIT CHECKOUT -- ARQUIVO.EXTENSÃO
##### DESFAZENDO ALTERAÇÃO LOCAL (STAGING AREA) → *DEPOIS DE ADC NA STAGED AREA*
	GIT RESET HEAD ARQUIVO.EXTENSÃO

PÓS UTILIZAR ESTE COMANDO... CASO SEJA EXIBIDA ESTA SAÍDA:

	UNSTAGED CHANGES AFTER RESET:
	M	ARQUIVO.EXTESNSÃO

SIGNIFICA QUE O COMANDO RESET **NÃO** ALTEROU O DIRETÓRIO DE TRABALHO. 
O QUE PODE SER FEITO ATRAVÉS DO COMANDO:

	GIT CHECKOUT ARQUIVO.EXTENSÃO

<H3>REPOSITÓRIO REMOTO</H3>
<H4 ALIGN="CENTER">VINCULANDO...</H4>

##### VINCULAR REPOSITÓRIO LOCAL COM UM REPOSITÓRIO REMOTO
	GIT REMOTE ADD ORIGIN GIT@GITHUB.COM:NOMEDEUSUARIO/NOMEDOREPOSITÓRIO.GIT
##### DESVINCULAR UM REPOSITÓRIO REMOTO
	GIT REMOTE RM CURSO-GIT

<H4 ALIGN="CENTER">VISUALIZANDO...</H4>

##### REPOSITÓRIOS
	GIT REMOTE
	GIT REMOTE -V
##### EXIBIR INFORMAÇÕES DOS REPOSITÓRIOS REMOTOS
	GIT REMOTE SHOW ORIGIN

<H4 ALIGN="CENTER">RENOMEANDO UM REPOSITÓRIO...</H4>

	GIT REMOTE RENAME ORIGIN CURSO-GIT

<H4 ALIGN="CENTER">CLONANDO...</H4>

##### CLONAR UM REPOSITÓRIO REMOTO JÁ EXISTENTE NO SEU PC
	GIT CLONE GIT@GITHUB.COM:NOMEDEUSUARIO/NOMEDOREPOSITORIO.GIT

<H4 ALIGN="CENTER">ATUALIZANDO...</H4>

##### ENVIAR ARQUIVOS/DIRETÓRIOS PARA O REPOSITÓRIO REMOTO

O PRIMEIRO **PUSH** DE UM REPOSITÓRIO DEVE CONTER O NOME DO 
REPOSITÓRIO REMOTO E O BRANCH.

	GIT PUSH -U ORIGIN MASTER
	
AINDA QUE UMA BOA PRATICA MANTER, OS DEMAIS **PUSHES** NÃO 
PRECISAM DESSA INFORMAÇÃO.

	GIT PUSH
	
##### BUSCAR AS ALTERAÇÕES, MAS NÃO APLICA-LAS NO BRANCH ATUAL
	GIT FETCH
##### ATUALIZAR OS ARQUIVOS NO BRANCH ATUAL
	GIT PULL

<H4 ALIGN="CENTER">TAGS...</H4>

##### CRIANDO UMA TAG LEVE
	GIT TAG VS-1.1
##### CRIANDO UMA TAG ANOTADA
	GIT TAG -A VS-1.1 -M "MINHA VERSÃO 1.1"
##### CRIANDO UMA TAG ASSINADA
PARA CRIAR UMA TAG ASSINADA É NECESSÁRIO UMA CHAVE PRIVADA 
(GNU PRIVACY GUARD - GPG).
    
    GIT TAG -S VS-1.1 -M "MINHA TAG ASSINADA 1.1"
    
##### CRIANDO TAG A PARTIR DE UM COMMIT (HASH)
	GIT TAG -A VS-1.2 9FCEB02
##### CRIANDO TAGS NO REPOSITÓRIO REMOTO
	GIT PUSH ORIGIN VS-1.2
##### CRIANDO TODAS AS TAGS LOCAIS NO REPOSITÓRIO REMOTO
	GIT PUSH ORIGIN --TAGS
	
<H4 ALIGN="CENTER">BRANCH...</H4>
A **MAIN** É A BRANCH PRINCIPAL DO GIT. VOCÊ PODE ENCONTRAR TAMBÉM PELO
NOME DE **MASTER**, PORÉM, ESTE TERMO DE CUNHO RACISTA FOI ELIMINADO,
MAS AINDA É ECONTRADO EM SOFTWARES DESATUALIZADOS.

O **HEAD** É UM PONTEIRO *ESPECIAL* QUE INDICA QUAL É A BRANCH ATUAL. 
POR PADRÃO, O **HEAD** APONTA PARA A BRANCH PRINCIPAL, **MAIN**.

##### CRIANDO UMA NOVA BRANCH
	GIT BRANCH NOMENOVABRANCH
##### TROCANDO PARA UM BRANCH (EXISTENTE)
	GIT CHECKOUT NOMEBRANCHEXISTENTE
	
...DESTE MOMENTO PRA FRENTE, O PONTEIRO PRINCIPAL **HEAD** ESTARÁ 
APONTANDO PARA O BRANCH NOMEBRANCHEXISTENTE.

##### CRIAR UMA NOVA BRANCH E TROCAR AUTOMATICAMENTE
	GIT CHECKOUT -B NOVABRANCH
##### VOLTAR PARA O BRANCH PRINCIPAL (MAIN)
	GIT CHECKOUT MAIN

<H4 ALIGN="CENTER">MERGING...</H4>
VALE RESSALTAR QUE, PARA FAZER O **MERGE**, É NECESSÁRIO ESTAR NA 
BRANCH QUE DEVERÁ RECEBER AS ALTERAÇÕES. OU SEJA, SE EU QUERO QUE 
A BRANCH **MAIN** RECEBA AS ATUALIZAÇÕES QUE FORAM FEITAS NA BRANCH
**UPSTREAM**, EU PRECISO QUE O **HEAD** ESTEJA APONTANDO PARA A MAIN
NO MOMENTO QUE FIZER O MERGING. <BR>

O MERGE AUTOMÁTICO SERÁ FEITO EM ARQUIVOS 
TEXTOS QUE NÃO SOFRERAM ALTERAÇÕES NAS MESMAS LINHAS, JÁ O MERGE 
MANUAL SERÁ FEITO EM ARQUIVOS TEXTOS QUE SOFRERAM ALTERAÇÕES NAS 
MESMAS LINHAS.

##### MERGE ENTRE OS BRANCHES → ESTANDO NA BRANCH MAIN
	GIT MERGE UPSTREAM

A MENSAGEM INDICANDO UM *MERGE* MANUAL SERÁ:

	AUTOMERGING ARQUIVO.EXTENSÃO
	CONFLICT (CONTENT): MERGE CONFLICT IN ARQUIVO.EXTENSÃO
	AUTOMATIC MERGE FAILED; FIX CONFLICTS AND THEN COMMIT THE RESULT.

##### APAGANDO UMA BRANCH
	GIT BRANCH -D NOMEDABRANCH
##### LISTAR BRANCHES 
	GIT BRANCH
##### LISTAR BRANCHES COM INFORMAÇÕES DOS ÚLTIMOS COMMITS
	GIT BRANCH -V
##### LISTAR BRANCHES QUE JÁ FORAM FUNDIDAS (MERGED) COM O **MAIN**
	GIT BRANCH --MERGED
##### LISTAR BRANCHES QUE NÃO FORAM FUNDIDAS (MERGED) COM O **MAIN**
	GIT BRANCH --NO-MERGED

<H4 ALIGN="CENTER">BRANCH REPOSITÓRIO REMOTO...</H4>

##### CRIANDO COM O MESMO NOME
	GIT PUSH ORIGIN NOMEDABRANCH
##### CRIANDO COM NOME DIFERENTE
	GIT PUSH ORIGIN NOMEDABRANCH:NOVABRANCH
##### BAIXAR UMA BRANCH REMOTO PARA EDIÇÃO
	GIT CHECKOUT -B NOMEDABRANCH ORIGIN/NOMEDABRANCH
##### APAGAR BRANCH REMOTO
	GIT PUSH ORIGIN:NOMEDABRANCH

<H4 ALIGN="CENTER">REBASING...</H4>

##### FAZENDO O **REBASE** ENTRE UMA BRANCH UPSTREAM E A MAIN.

	GIT CHECKOUT EXPERIMENT
	GIT REBASE MAIN

<P ALIGN="CENTER">
    ...MAIS INFORMAÇÕES SOBRE REBASE:  
    <A HREF="HTTP://GIT-SCM.COM/BOOK/EN/GIT-BRANCHING-REBASING" TARGET="_BLANK">GIT REBASING</A>
</P>

<H4 ALIGN="CENTER">STASHING...</H4>
PARA ALTERNAR ENTRE UMA BRANCH E OUTRA É NECESSÁRIO FAZER O COMMIT 
DAS ALTERAÇÕES ATUAIS PARA DEPOIS TROCAR DE BRANCH. SE EXISTIR A 
NECESSIDADE DE REALIZAR A TROCA SEM FAZER O COMMIT É POSSÍVEL CRIAR 
UM **STASH**. 

O STASH É COMO SE FOSSE UMA BRANCH TEMPORÁRIA QUE CONTEM APENAS AS 
ALTERAÇÕES AINDA NÃO COMMITADAS.

##### CRIAR UM STASH
	GIT STASH
##### LISTAR STASHES
	GIT STASH LIST
##### VOLTAR PARA O ÚLTIMO STASH
	GIT STASH APPLY
##### VOLTAR PARA UM STASH ESPECÍFICO
	GIT STASH APPLY STASH@{2}
ONDE **2** É O INDÍCE DO STASH DESEJADO.
##### CRIAR UMA BRANCH A PARTIR DE UM STASH
	GIT STASH BRANCH NOMEBRANCH

<H4 ALIGN="CENTER">REESCREVENDO HISTÓRICO...</H4>

##### ALTERANDO MENSAGENS DE COMMIT
	GIT COMMIT --AMEND -M "NOVA MENSAGEM"
##### ALTERAR 3 ÚLTIMOS COMMITS
	GIT REBASE -I HEAD~3

O EDITOR DE TEXTO SERÁ ABERTO COM AS LINHAS REPRESENTANDO OS 3 ÚLTIMOS COMMITS.

	PICK F7F3F6D CRIEI UMA BRANCH PARA O MENU
	PICK 310154E ATUALIZEI AS FONTES DO MENU
	PICK A5F4A0D FINALIZEI O MENU

ALTERE PARA EDIT OS COMMITS QUE DESEJA REALIZAR ALTERAÇÕES.

	EDIT F7F3F6D CRIEI UMA BRANCH PARA O MENU E RODAPÉ
	PICK 310154E ATUALIZEI AS FONTES DO MENU
	PICK A5F4A0D FINALIZEI O MENU

FECHE O EDITOR DE TEXTO.

AGORA, DIGITE ESTE COMANDO PARA ALTERAR A MENSAGEM DO COMMIT 
QUE FOI MARCADO COMO **EDIT**.

	GIT COMMIT –AMEND -M “NOVA MENSAGEM”

APLIQUE A ALTERAÇÃO

	GIT REBASE --CONTINUE

**ATENÇÃO:** É POSSÍVEL ALTERAR A ORDEM DOS COMMITS OU REMOVER 
UM COMMIT APENAS MUDANDO AS LINHAS OU REMOVENDO.

<H4 ALIGN="CENTER">SQUASHING...</H4>

##### JUNTANDO VÁRIOS COMMITS
SEGUIR OS MESMOS PASSOS ACIMA, PORÉM MARCAR OS COMMTIS QUE DEVEM 
SER JUNTADOS COM **SQUASH**

<H4 ALIGN="CENTER">REMOVENDO HISTÓRICO...</H4>	

##### REMOVER TODO HISTÓRICO DE UM ARQUIVO
	GIT FILTER-BRANCH --TREE-FILTER 'RM -F PASSWORDS.TXT' HEAD

<H4 ALIGN="CENTER">BISECT...</H4>
O BISECT (PESQUISA BINÁRIA) É ÚTIL PARA ENCONTRAR UM COMMIT QUE 
ESTÁ GERANDO UM BUG OU UMA INCONSISTÊNCIA ENTRE UMA SEQUÊNCIA 
DE COMMITS.

##### INICIAR PESQUISA BINÁRIA
	GIT BISECT START
##### MARCAR O COMMIT ATUAL COMO RUIM
	GIT BISECT BAD
##### MARCAR O COMMIT DE UMA TAG QUE ESTA SEM O BUG/INCONSISTÊNCIA
	GIT BISECT GOOD VS-1.1
##### MARCAR O COMMIT COMO GOOD (BOM)

O GIT IRÁ NAVEGAR ENTRE OS COMMITS PARA AJUDAR A INDENTIFICAR O 
COMMIT QUE ESTÁ COM O PROBLEMA. SE O COMMIT ATUAL NÃO ESTIVER 
QUEBRADO, ENTÃO É NECESSÁRIO MARCA-LO COMO **BOM**.

	GIT BISECT GOOD

##### MARCAR O COMMIT COMO BAD (RUIM)
SE O COMMIT ESTIVER COM O PROBLEMA, ENTÃO ELE DEVERÁ SER MARCADO 
COMO **RUIM**.

 	GIT BISECT BAD
 
##### FINALIZAR A PESQUISA BINÁRIA
DEPOIS DE ENCONTRAR O COMMIT COM PROBLEMA, PARA RETORNAR PARA O 
*HEAD* UTILIZE:
	
	GIT BISECT RESET

<HR>
ESTE CONTEÚDO NÃO ESTÁ COMPLETO, CASO QUEIRA CONTRIBUIR, SERÁ MUITO BEM ACEITO!

VÍDEOS MOSTRANDO NA PRÁTICA → [CANAL CÓDIGOS SIMPLES](HTTPS://WWW.YOUTUBE.COM/CHANNEL/UC8FRZFYGD21_D8DWUECFUHW)
</BR>CURSOS | MAIS INFORMAÇÕES → <A HREF="HTTPS://API.WHATSAPP.COM/SEND?PHONE=5511979714423">WHATSAPP</A>
